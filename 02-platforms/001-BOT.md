# ü§ñ BOT - LOCKDOWN

## Desenvolvimento do Discord Bot com Discord.js

---

## üìñ √çndice

1. [Vis√£o Geral](#vis√£o-geral)
2. [Setup](#setup)
3. [Estrutura](#estrutura)
4. [Handlers](#handlers)
5. [Commands](#commands)
6. [Events](#events)
7. [API Integration](#api-integration)
8. [Pub/Sub (Redis)](#pubsub-redis)
9. [Deployments](#deployments)

---

## üìã Vis√£o Geral

### O que √© o Bot LOCKDOWN?

Discord bot **agn√≥stico** que:

- ‚úÖ Consome API REST do backend
- ‚úÖ Executa comandos de modera√ß√£o
- ‚úÖ Escuta eventos do Redis
- ‚úÖ N√£o conhece l√≥gica de neg√≥cio (s√≥ chama API)

### Stack

```
Discord.js 14.x     ‚Üí Interface Discord
Axios               ‚Üí HTTP requests
ioredis             ‚Üí Pub/Sub
TypeScript          ‚Üí Type-safety
Pino                ‚Üí Logging
```

### Filosofia

```
Bot ‚Üê HTTP API ‚Üê Database
Bot ‚Üê Redis Pub/Sub ‚Üê Eventos
Bot ‚Üí Discord API ‚Üí Mensagens/A√ß√µes
```

---

## üõ†Ô∏è Setup

### 1. Instalar Depend√™ncias

```bash
cd packages/lockdown-bot
pnpm install
```

### 2. Configurar .env

**`packages/lockdown-bot/.env`:**

```ini
# =====================================================
# DISCORD
# =====================================================
DISCORD_TOKEN=your_bot_token_here
DISCORD_CLIENT_ID=your_client_id_here

# =====================================================
# BACKEND API
# =====================================================
API_BASE_URL=http://localhost:3000/api/v1
API_TIMEOUT=5000
API_JWT_SECRET=your_jwt_secret_here

# =====================================================
# REDIS
# =====================================================
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0

# =====================================================
# LOGGING
# =====================================================
LOG_LEVEL=info
```

### 3. Rodar Bot

```bash
# Development mode (watch)
pnpm dev

# Esperado:
# [bot] ‚úÖ Bot is ready! Logged in as: BotName#0000
```

---

## üìÅ Estrutura

```
packages/lockdown-bot/src/
‚îú‚îÄ commands/                # Slash commands
‚îÇ  ‚îú‚îÄ moderation/
‚îÇ  ‚îÇ  ‚îú‚îÄ ban.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ kick.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ mute.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ warn.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ index.ts (agregador)
‚îÇ  ‚îú‚îÄ config/
‚îÇ  ‚îÇ  ‚îú‚îÄ autorole.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ index.ts
‚îÇ  ‚îî‚îÄ index.ts (carrega todos)
‚îÇ
‚îú‚îÄ events/                  # Event listeners
‚îÇ  ‚îú‚îÄ ready.ts             # Bot conectou
‚îÇ  ‚îú‚îÄ guildCreate.ts       # Bot adicionado
‚îÇ  ‚îú‚îÄ messageCreate.ts     # Mensagem recebida
‚îÇ  ‚îú‚îÄ redis.ts             # Eventos Redis
‚îÇ  ‚îî‚îÄ index.ts (agregador)
‚îÇ
‚îú‚îÄ handlers/               # L√≥gica reutiliz√°vel
‚îÇ  ‚îú‚îÄ CommandHandler.ts    # Carrega commands
‚îÇ  ‚îú‚îÄ EventHandler.ts      # Carrega events
‚îÇ  ‚îú‚îÄ APIHandler.ts        # Requisi√ß√µes HTTP
‚îÇ  ‚îî‚îÄ RedisHandler.ts      # Pub/Sub
‚îÇ
‚îú‚îÄ services/              # Servi√ßos do bot
‚îÇ  ‚îú‚îÄ ModerationService.ts # Abstra√ß√£o da API
‚îÇ  ‚îú‚îÄ GuildService.ts      # Gerenciar guilds
‚îÇ  ‚îú‚îÄ LoggerService.ts     # Logging
‚îÇ  ‚îî‚îÄ CacheService.ts      # Cache local
‚îÇ
‚îú‚îÄ types/                 # TypeScript types
‚îÇ  ‚îú‚îÄ bot.types.ts        # Command types
‚îÇ  ‚îú‚îÄ api.types.ts        # API responses
‚îÇ  ‚îî‚îÄ events.types.ts     # Event payloads
‚îÇ
‚îú‚îÄ utils/                 # Utilities
‚îÇ  ‚îú‚îÄ constants.ts        # Constantes
‚îÇ  ‚îú‚îÄ embed.ts            # Discord embeds
‚îÇ  ‚îú‚îÄ validators.ts       # Valida√ß√µes
‚îÇ  ‚îî‚îÄ formatters.ts       # Formata√ß√£o
‚îÇ
‚îú‚îÄ config/               # Configura√ß√£o
‚îÇ  ‚îú‚îÄ environment.ts      # Env vars
‚îÇ  ‚îú‚îÄ discord.ts          # Discord client setup
‚îÇ  ‚îú‚îÄ redis.ts            # Redis setup
‚îÇ  ‚îî‚îÄ logger.ts           # Pino setup
‚îÇ
‚îî‚îÄ index.ts              # Entry point
```

---

## üéÆ Commands

### Estrutura de Command

```typescript
/**
 * - @file ban.ts
 *
 * =====================================================================
 * ===================== FILE METADATA ================================
 * =====================================================================
 *
 * @author Mickael Virtuoso
 * @since 2025-02-05
 *
 * =====================================================================
 * ====================== GENERAL DESCRIPTION ==========================
 * =====================================================================
 *
 * @description
 * Slash command para banir usu√°rios
 *
 */

import {
  SlashCommandBuilder,
  CommandInteraction,
  PermissionFlagsBits,
  EmbedBuilder,
} from 'discord.js';
import { logger } from '@config/logger';
import { ModerationService } from '@services/ModerationService';

export default {
  data: new SlashCommandBuilder()
    .setName('ban')
    .setDescription('Ban a user from the server')
    .addUserOption((option) =>
      option.setName('user').setDescription('User to ban').setRequired(true)
    )
    .addStringOption((option) =>
      option.setName('reason').setDescription('Reason for the ban').setRequired(false)
    )
    .addNumberOption((option) =>
      option
        .setName('days')
        .setDescription('Days until auto-unban (0 = permanent)')
        .setRequired(false)
        .setMinValue(0)
        .setMaxValue(30)
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.BanMembers)
    .setDMPermission(false),

  async execute(interaction: CommandInteraction): Promise<void> {
    logger.debug(`[${this.data.name}] "üì® command received from ${interaction.user.id}"`);

    try {
      // Defer reply (pode demorar um pouco)
      await interaction.deferReply();

      // Get options
      const user = interaction.options.getUser('user', true);
      const reason = interaction.options.getString('reason') || 'No reason provided';
      const days = interaction.options.getNumber('days') || 0;

      // Valida√ß√µes
      if (!interaction.guildId) {
        throw new Error('This command can only be used in a guild');
      }

      if (user.id === interaction.user.id) {
        throw new Error('You cannot ban yourself');
      }

      const moderationService = new ModerationService();

      // Chamada √† API
      const ban = await moderationService.banUser({
        guildId: interaction.guildId,
        userId: user.id,
        reason,
        moderatorId: interaction.user.id,
        expiresAt: days > 0 ? new Date(Date.now() + days * 24 * 60 * 60 * 1000) : undefined,
      });

      // Responder com embed
      const embed = new EmbedBuilder()
        .setColor('#ff0000')
        .setTitle('‚úÖ User Banned')
        .addFields(
          { name: 'User', value: `${user.username}#${user.discriminator}` },
          { name: 'Reason', value: reason },
          { name: 'Duration', value: days > 0 ? `${days} days` : 'Permanent' }
        )
        .setTimestamp();

      await interaction.editReply({ embeds: [embed] });

      logger.info(
        `[${this.data.name}] "üö´ ban created for user: ${user.id} in guild: ${interaction.guildId}"`
      );
    } catch (error) {
      logger.error(`[${this.data.name}] "‚ùå error: ${error}"`);

      const errorEmbed = new EmbedBuilder()
        .setColor('#ff0000')
        .setTitle('‚ùå Error')
        .setDescription(error instanceof Error ? error.message : 'Unknown error')
        .setTimestamp();

      await interaction.editReply({ embeds: [errorEmbed] });
    }
  },
};
```

### Registrar Commands

**`packages/lockdown-bot/src/handlers/CommandHandler.ts`:**

```typescript
/**
 * - @file CommandHandler.ts
 *
 * =====================================================================
 * ===================== FILE METADATA ================================
 * =====================================================================
 *
 * @author Mickael Virtuoso
 * @since 2025-02-05
 *
 * =====================================================================
 * ====================== GENERAL DESCRIPTION ==========================
 * =====================================================================
 *
 * @description
 * Handler para carregar e registrar slash commands
 *
 */

import { Client, Collection, REST, Routes } from 'discord.js';
import { readdirSync, statSync } from 'fs';
import { join } from 'path';
import { logger } from '@config/logger';

export default class CommandHandler {
  private client: Client;
  private commands: Collection<string, any>;

  constructor(client: Client) {
    this.client = client;
    this.commands = new Collection();
  }

  async loadCommands(): Promise<void> {
    logger.info(`[${this.constructor.name}] "üîÑ loading commands..."`);

    const commandsPath = join(__dirname, '../commands');
    const categories = readdirSync(commandsPath);

    for (const category of categories) {
      const categoryPath = join(commandsPath, category);

      if (!statSync(categoryPath).isDirectory()) continue;

      const commandFiles = readdirSync(categoryPath).filter(
        (file) => file.endsWith('.ts') || file.endsWith('.js')
      );

      for (const file of commandFiles) {
        if (file === 'index.ts' || file === 'index.js') continue;

        const commandPath = join(categoryPath, file);
        const command = require(commandPath).default;

        if (!command.data || !command.execute) {
          logger.warn(`[${this.constructor.name}] "‚ö†Ô∏è skipping ${file}: missing data or execute"`);
          continue;
        }

        this.commands.set(command.data.name, command);
        logger.debug(`[${this.constructor.name}] "‚úÖ loaded command: ${command.data.name}"`);
      }
    }

    logger.info(`[${this.constructor.name}] "‚úÖ loaded ${this.commands.size} commands"`);

    await this.registerCommands();
  }

  private async registerCommands(): Promise<void> {
    logger.debug(`[${this.constructor.name}] "üì§ registering commands with Discord..."`);

    const commands = Array.from(this.commands.values()).map((cmd) => cmd.data);

    const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN || '');

    try {
      await rest.put(Routes.applicationCommands(process.env.DISCORD_CLIENT_ID || ''), {
        body: commands,
      });

      logger.info(
        `[${this.constructor.name}] "‚úÖ registered ${commands.length} commands globally"`
      );
    } catch (error) {
      logger.error(`[${this.constructor.name}] "‚ùå failed to register commands: ${error}"`);
    }
  }

  public getCommand(name: string) {
    return this.commands.get(name);
  }

  public getAllCommands() {
    return this.commands;
  }
}
```

---

## üéØ Events

### Command Interaction Event

**`packages/lockdown-bot/src/events/interactionCreate.ts`:**

```typescript
/**
 * - @file interactionCreate.ts
 *
 * =====================================================================
 * ===================== FILE METADATA ================================
 * =====================================================================
 *
 * @author Mickael Virtuoso
 * @since 2025-02-05
 *
 * =====================================================================
 * ====================== GENERAL DESCRIPTION ==========================
 * =====================================================================
 *
 * @description
 * Executar slash commands quando intera√ß√£o √© recebida
 *
 */

import { Interaction, EmbedBuilder } from 'discord.js';
import { logger } from '@config/logger';

export default {
  name: 'interactionCreate',
  async execute(interaction: Interaction): Promise<void> {
    logger.debug(`[${this.name}] "üì® interaction received from ${interaction.user?.id}"`);

    if (!interaction.isChatInputCommand()) return;

    const commandHandler = global.commandHandler;
    const command = commandHandler.getCommand(interaction.commandName);

    if (!command) {
      logger.warn(`[${this.name}] "‚ö†Ô∏è command not found: ${interaction.commandName}"`);

      const embed = new EmbedBuilder()
        .setColor('#ff0000')
        .setTitle('‚ùå Command Not Found')
        .setDescription(`Command \`${interaction.commandName}\` was not found`);

      await interaction.reply({ embeds: [embed], ephemeral: true });
      return;
    }

    try {
      await command.execute(interaction);

      logger.info(
        `[${this.name}] "‚úÖ executed command: ${interaction.commandName} by ${interaction.user?.id}"`
      );
    } catch (error) {
      logger.error(`[${this.name}] "‚ùå error executing command: ${error}"`);

      const embed = new EmbedBuilder()
        .setColor('#ff0000')
        .setTitle('‚ùå Error')
        .setDescription('An error occurred while executing the command');

      if (interaction.replied || interaction.deferred) {
        await interaction.editReply({ embeds: [embed] });
      } else {
        await interaction.reply({ embeds: [embed], ephemeral: true });
      }
    }
  },
};
```

### Redis Event

**`packages/lockdown-bot/src/events/redis.ts`:**

```typescript
/**
 * - @file redis.ts
 *
 * =====================================================================
 * ===================== FILE METADATA ================================
 * =====================================================================
 *
 * @author Mickael Virtuoso
 * @since 2025-02-05
 *
 * =====================================================================
 * ====================== GENERAL DESCRIPTION ==========================
 * =====================================================================
 *
 * @description
 * Escutar eventos do Redis e fazer a√ß√µes no Discord
 *
 */

import { Client, EmbedBuilder } from 'discord.js';
import { redis } from '@config/redis';
import { logger } from '@config/logger';

export default {
  name: 'redis',
  async execute(client: Client): Promise<void> {
    logger.info(`[${this.name}] "üî¥ subscribing to Redis events"`);

    // Criar subscriber separado
    const subscriber = redis.duplicate();

    // Eventos a escutar
    const events = ['ban:created', 'kick:executed', 'mute:applied', 'warning:added'];

    await subscriber.subscribe(events, (err) => {
      if (err) {
        logger.error(`[${this.name}] "‚ùå subscription error: ${err}"`);
      } else {
        logger.info(`[${this.name}] "‚úÖ subscribed to ${events.length} events"`);
      }
    });

    // Listener de mensagens
    subscriber.on('message', async (channel, message) => {
      logger.debug(`[${this.name}] "üì® event received: ${channel}"`);

      const data = JSON.parse(message);

      try {
        switch (channel) {
          case 'ban:created':
            await handleBanCreated(client, data);
            break;

          case 'kick:executed':
            await handleKickExecuted(client, data);
            break;

          case 'mute:applied':
            await handleMuteApplied(client, data);
            break;

          case 'warning:added':
            await handleWarningAdded(client, data);
            break;

          default:
            logger.warn(`[${this.name}] "‚ö†Ô∏è unknown event: ${channel}"`);
        }
      } catch (error) {
        logger.error(`[${this.name}] "‚ùå error handling event: ${error}"`);
      }
    });
  },
};

async function handleBanCreated(client: Client, data: any): Promise<void> {
  logger.info(`[handleBanCreated] "üö´ ban created for user: ${data.userId}"`);

  const guild = client.guilds.cache.get(data.guildId);
  if (!guild) return;

  const channel = guild.channels.cache.find((ch) => ch.name === 'mod-logs');
  if (!channel || !channel.isTextBased()) return;

  const embed = new EmbedBuilder()
    .setColor('#ff0000')
    .setTitle('üö´ User Banned')
    .addFields(
      { name: 'User ID', value: data.userId },
      { name: 'Reason', value: data.reason || 'No reason' },
      { name: 'Duration', value: data.expiresAt ? 'Temporary' : 'Permanent' }
    )
    .setTimestamp();

  await channel.send({ embeds: [embed] });
}

async function handleKickExecuted(client: Client, data: any): Promise<void> {
  logger.info(`[handleKickExecuted] "üë¢ kick executed for user: ${data.userId}"`);

  // Similar to handleBanCreated
}

async function handleMuteApplied(client: Client, data: any): Promise<void> {
  logger.info(`[handleMuteApplied] "üîá mute applied to user: ${data.userId}"`);

  // Similar to handleBanCreated
}

async function handleWarningAdded(client: Client, data: any): Promise<void> {
  logger.info(`[handleWarningAdded] "‚ö†Ô∏è warning added to user: ${data.userId}"`);

  // Similar to handleBanCreated
}
```

---

## üîå API Integration

### ModerationService

**`packages/lockdown-bot/src/services/ModerationService.ts`:**

```typescript
/**
 * - @file ModerationService.ts
 *
 * =====================================================================
 * ===================== FILE METADATA ================================
 * =====================================================================
 *
 * @author Mickael Virtuoso
 * @since 2025-02-05
 *
 * =====================================================================
 * ====================== GENERAL DESCRIPTION ==========================
 * =====================================================================
 *
 * @description
 * Abstra√ß√£o da API de modera√ß√£o para o bot
 *
 */

import axios, { AxiosInstance } from 'axios';
import { logger } from '@config/logger';
import jwt from 'jsonwebtoken';

export interface BanRequest {
  guildId: string;
  userId: string;
  reason?: string;
  moderatorId: string;
  expiresAt?: Date;
}

export default class ModerationService {
  private api: AxiosInstance;
  private jwtSecret: string;

  constructor() {
    this.jwtSecret = process.env.API_JWT_SECRET || '';

    this.api = axios.create({
      baseURL: process.env.API_BASE_URL || 'http://localhost:3000/api/v1',
      timeout: parseInt(process.env.API_TIMEOUT || '5000'),
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Adicionar JWT token em cada request
    this.api.interceptors.request.use((config) => {
      const token = jwt.sign({ botId: 'lockdown-bot' }, this.jwtSecret, {
        expiresIn: '24h',
      });

      config.headers.Authorization = `Bearer ${token}`;
      return config;
    });
  }

  async banUser(data: BanRequest) {
    logger.debug(
      `[${this.constructor.name}] "üîÑ banning user: ${data.userId} in guild: ${data.guildId}"`
    );

    try {
      const response = await this.api.post('/moderation/bans', {
        guildId: data.guildId,
        userId: data.userId,
        reason: data.reason || 'No reason provided',
        moderatorId: data.moderatorId,
        expiresAt: data.expiresAt?.toISOString(),
      });

      logger.info(`[${this.constructor.name}] "‚úÖ ban created: ${response.data.data.id}"`);
      return response.data.data;
    } catch (error) {
      logger.error(`[${this.constructor.name}] "‚ùå failed to ban user: ${error}"`);
      throw error;
    }
  }

  async kickUser(data: { guildId: string; userId: string; reason?: string; moderatorId: string }) {
    logger.debug(`[${this.constructor.name}] "üîÑ kicking user: ${data.userId}"`);

    try {
      const response = await this.api.post('/moderation/kicks', data);
      logger.info(`[${this.constructor.name}] "‚úÖ kick executed: ${response.data.data.id}"`);
      return response.data.data;
    } catch (error) {
      logger.error(`[${this.constructor.name}] "‚ùå failed to kick user: ${error}"`);
      throw error;
    }
  }

  async muteUser(data: {
    guildId: string;
    userId: string;
    reason?: string;
    moderatorId: string;
    duration?: number;
    expiresAt?: Date;
  }) {
    logger.debug(`[${this.constructor.name}] "üîÑ muting user: ${data.userId}"`);

    try {
      const response = await this.api.post('/moderation/mutes', {
        ...data,
        expiresAt: data.expiresAt?.toISOString(),
      });

      logger.info(`[${this.constructor.name}] "‚úÖ mute applied: ${response.data.data.id}"`);
      return response.data.data;
    } catch (error) {
      logger.error(`[${this.constructor.name}] "‚ùå failed to mute user: ${error}"`);
      throw error;
    }
  }

  async warnUser(data: { guildId: string; userId: string; reason?: string; moderatorId: string }) {
    logger.debug(`[${this.constructor.name}] "üîÑ warning user: ${data.userId}"`);

    try {
      const response = await this.api.post('/moderation/warnings', data);
      logger.info(`[${this.constructor.name}] "‚úÖ warning added: ${response.data.data.id}"`);
      return response.data.data;
    } catch (error) {
      logger.error(`[${this.constructor.name}] "‚ùå failed to warn user: ${error}"`);
      throw error;
    }
  }
}
```

---

## üåç Rodar Bot

### Development

```bash
cd packages/lockdown-bot
pnpm dev

# Esperado:
# [bot] ‚úÖ Bot is ready!
# [bot] ‚úÖ loaded 8 commands
# [bot] ‚úÖ subscribed to 4 events
```

### Production

```bash
# Build
pnpm build

# Start com PM2 (via root)
pnpm start:bot:pm2
```

---

## üìö Refer√™ncias

- [SETUP.md](./SETUP.md) - Setup inicial
- [API.md](./API.md) - Endpoints dispon√≠veis
- [BACKEND.md](./BACKEND.md) - Como backend funciona
- [Discord.js Docs](https://discord.js.org)

---

**Happy coding!** ü§ñ
